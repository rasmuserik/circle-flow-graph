// Generated by CoffeeScript 1.6.3
(function() {
  var Node, args, circlesPerLine, count, ctx, curveness, cx0, cx1, cy0, cy1, data, end, entry, entryDir, entryPoint, exitDir, exitPoint, fnNames, fns, height, hspace, i, id, key, length, nodeCount, nodes, odd, prev, radius, root, size, t0, t1, val, w, width, x, x0, x1, y, y0, y1, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;

  t0 = +new Date();

  height = canvas.width;

  size = 80;

  count = 20;

  hspace = 1.3;

  width = size * 5;

  radius = size * .40;

  ctx = canvas.getContext("2d");

  ctx.lineWidth = 2;

  circlesPerLine = 3;

  curveness = 1.9;

  ctx.fillRect(0, 0, 1000, 1000);

  nodes = {};

  fns = {};

  nodeCount = 0;

  if (true) {
    Node = function(prev, op, inputs) {
      var i, _i, _len, _ref;
      this.op = op;
      this.id = nodeCount;
      ++nodeCount;
      if (prev !== void 0) {
        this.prev = prev.id;
        nodes[this.prev].next = this.id;
      }
      this["in"] = inputs;
      this.out = [];
      _ref = this["in"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        nodes[i].out.push(this.id);
      }
      nodes[this.id] = this;
      return this.val = this["eval"]();
    };
    Node.prototype.drawShadow = function() {
      if (this.mark) {
        ctx.setShadow(0, 0, radius * 1, hashcolor.light("" + this.val));
        ctx.beginPath();
        ctx.arc(this.x, this.y, radius + 1, 0, Math.PI * 2);
        ctx.fillStyle = "#000";
        ctx.fill();
        ctx.clearShadow();
      }
      if (this.next !== void 0) {
        return nodes[this.next].drawShadow();
      }
    };
    Node.prototype.drawObj = function() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fill();
      ctx.strokeStyle = hashcolor.intToColor(hashcolor.val("" + this.val));
      ctx.stroke();
      ctx.font = "" + (size / 3) + "px ubuntu";
      ctx.fillStyle = "#000";
      ctx.fillText(this.op, this.x - size * .2, this.y - size * .05);
      ctx.fillText(this.val, this.x - size * .2, this.y + size * .25);
      if (this.next !== void 0) {
        return nodes[this.next].drawObj();
      }
    };
    Node.prototype.outPoint = function() {
      var d;
      d = Math.SQRT1_2 * radius;
      return [this.x + d, this.y + d, this.x + d * curveness, this.y + d * curveness];
    };
    Node.prototype.inPoint = function(i) {
      var a, t, w, x, y;
      t = radius * Math.sqrt(.5);
      w = 2;
      a = Math.PI * 1.25 + w * (i + 1) / (this["in"].length + 1) - w / 2;
      y = Math.sin(a);
      x = Math.cos(a);
      return [this.x + x * radius, this.y + y * radius, this.x + x * radius * curveness, this.y + y * radius * curveness];
    };
    Node.prototype.drawLines = function() {
      var cx0, cx1, cy0, cy1, i, src, x0, x1, y0, y1, _i, _ref, _ref1, _ref2;
      for (i = _i = 0, _ref = this["in"].length - 1; _i <= _ref; i = _i += 1) {
        src = nodes[this["in"][i]];
        _ref1 = src.outPoint(), x0 = _ref1[0], y0 = _ref1[1], cx0 = _ref1[2], cy0 = _ref1[3];
        _ref2 = this.inPoint(i), x1 = _ref2[0], y1 = _ref2[1], cx1 = _ref2[2], cy1 = _ref2[3];
        ctx.beginPath();
        ctx.strokeStyle = hashcolor.intToColor(hashcolor.val("" + src.val));
        ctx.moveTo(x0, y0);
        ctx.quadraticCurveTo(cx0, cy0, (cx0 + cx1) / 2, (cy0 + cy1) / 2);
        ctx.quadraticCurveTo(cx1, cy1, x1, y1);
        ctx.stroke();
      }
      if (this.next !== void 0) {
        return nodes[this.next].drawLines();
      }
    };
    Node.prototype.layout = function(x, y) {
      this.x = x;
      this.y = y;
      x += size;
      if (x > width - size / 2) {
        x -= width - size / 2;
        y += size * hspace;
        if (x < size / 2) {
          x += size;
        }
      }
      if (this.next !== void 0) {
        return nodes[this.next].layout(x, y);
      }
    };
    Node.prototype["eval"] = function() {
      if (typeof this.op === "number") {
        return this.op;
      } else if (typeof fns[this.op] === "function") {
        return fns[this.op].apply(null, this["in"].map(function(o) {
          return nodes[o]["eval"]();
        }));
      } else {
        throw this.op;
      }
    };
    fns["+"] = function(a, b) {
      return a + b;
    };
    fns["-"] = function(a, b) {
      return a - b;
    };
    fns["xor"] = function(a, b) {
      return a ^ b;
    };
    fns["&"] = function(a, b) {
      return a & b;
    };
    fns["or"] = function(a, b) {
      return a | b;
    };
    fnNames = Object.keys(fns);
    root = new Node(void 0, 1, []);
    prev = root;
    for (i = _i = 0; 0 <= count ? _i <= count : _i >= count; i = 0 <= count ? ++_i : --_i) {
      if (Math.random() < .3 || nodeCount < 2) {
        prev = new Node(prev, 1 + Math.random() * 9 | 0, []);
      } else {
        length = 1 + Math.random() * Math.random() * 4 | 0;
        length = 2;
        args = [];
        for (i = _j = 0, _ref = length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
          args.push(nodeCount - Math.random() * Math.random() * nodeCount | 0);
        }
        prev = new Node(prev, fnNames[Math.random() * fnNames.length | 0], args);
      }
      if (Math.random() < .2) {
        prev.mark = true;
      }
    }
    t0 = Date.now();
    root.layout(size / 2, size / 2);
    root.drawShadow();
    console.log("time:", Date.now() - t0);
    t0 = Date.now();
    root.drawLines();
    console.log("time:", Date.now() - t0);
    t0 = Date.now();
    root.drawObj();
    console.log("time:", Date.now() - t0);
    t0 = Date.now();
  } else {
    data = {
      a: [],
      b: [],
      c: ["a", "b"],
      d: ["c", "b"],
      e: ["c", "b"],
      f: ["d", "e"],
      g: ["d", "c"],
      h: [],
      i: ["f", "g", "h"],
      j: ["c"],
      k: ["d", "c"],
      l: ["f", "g", "h"],
      m: ["d", "c"],
      n: [],
      o: ["l", "n", "g"],
      p: ["l", "o"],
      q: ["p"],
      r: ["n", "o"],
      s: ["r", "q", "p"],
      t: ["r", "g"],
      u: ["s"],
      v: ["r", "t"],
      w: ["s", "u"],
      x: ["r", "u", "v", "t", "f", "s"],
      y: ["t", "x"],
      z: ["w"]
    };
    for (key in data) {
      val = data[key];
      data[key] = {
        "in": val,
        out: [],
        id: key
      };
    }
    for (key in data) {
      val = data[key];
      _ref1 = val["in"];
      for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
        id = _ref1[_k];
        data[id].out.push(key);
      }
    }
    x = 0;
    y = 0;
    odd = false;
    for (key in data) {
      val = data[key];
      val.x = x;
      val.y = y;
      x += size;
      if (x + size > width) {
        odd = !odd;
        x = odd ? size / 2 : 0;
        y = y + size * 1.2;
      }
    }
    exitPoint = function(data) {
      var t;
      t = radius * Math.sqrt(.5);
      return [data.x + size / 2 + t, data.y + size / 2 + t];
    };
    exitDir = function(data) {
      return [data.x + size / 2 + radius * 1.5, data.y + size / 2 + radius * 1.5];
    };
    entryDir = function(data, i, n) {
      var _ref2, _ref3;
      _ref2 = entryPoint(data, i, n), x = _ref2[0], y = _ref2[1];
      _ref3 = [x - (data.x + width / 2), y - (data.y + width / 2)], x = _ref3[0], y = _ref3[1];
      return [(data.x + width / 2) + 1.15 * x, (data.y + width / 2) + 1.15 * y];
    };
    entryPoint = function(data, i, n) {
      var a, t, w;
      t = radius * Math.sqrt(.5);
      w = 2;
      a = Math.PI * 1.25 + w * (i + 1) / (n + 1) - w / 2;
      y = Math.sin(a);
      x = Math.cos(a);
      console.log(data);
      console.log(x, y, a, w, t, i, n);
      [data.x + size / 2 - t, data.y + size / 2 - t];
      return [data.x + size / 2 + x * radius, data.y + size / 2 + y * radius];
    };
    ctx.lineWidth = 2;
    for (key in data) {
      end = data[key];
      for (i = _l = 0, _ref2 = end["in"].length - 1; _l <= _ref2; i = _l += 1) {
        val = data[end["in"][i]];
        console.log(val, end);
        ctx.beginPath();
        ctx.strokeStyle = hashcolor.intToColor(hashcolor.val(val.id));
        _ref3 = exitPoint(val), x0 = _ref3[0], y0 = _ref3[1];
        _ref4 = exitDir(val), cx0 = _ref4[0], cy0 = _ref4[1];
        entry = end;
        _ref5 = entryPoint(entry, i, end["in"].length), x1 = _ref5[0], y1 = _ref5[1];
        _ref6 = entryDir(entry, i, end["in"].length), cx1 = _ref6[0], cy1 = _ref6[1];
        ctx.moveTo(x0, y0);
        ctx.quadraticCurveTo(cx0, cy0, (cx0 + cx1) / 2, (cy0 + cy1) / 2);
        ctx.quadraticCurveTo(cx1, cy1, x1, y1);
        ctx.stroke();
      }
    }
    for (key in data) {
      val = data[key];
      ctx.beginPath();
      ctx.arc(val.x + size / 2, val.y + size / 2, radius, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(255,255,255,0.6)";
      ctx.fill();
      ctx.strokeStyle = hashcolor.intToColor(hashcolor.val(key));
      ctx.stroke();
      ctx.font = "" + (size / 2) + "px ubuntu";
      ctx.fillStyle = "#000";
      ctx.fillText(key, val.x + size * .35, val.y + size * .65);
    }
    t1 = +new Date();
    w = 600;
    ctx.beginPath();
    ctx.moveTo(w / 2, 0);
    ctx.quadraticCurveTo(w, 0, w, 100);
    ctx.quadraticCurveTo(w, 200, w / 2, 200);
    ctx.quadraticCurveTo(0, 200, 0, 100);
    ctx.quadraticCurveTo(0, 0, w / 2, 0);
    ctx.stroke();
  }

}).call(this);
